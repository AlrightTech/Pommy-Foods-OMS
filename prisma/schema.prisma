// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User & Authentication
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String
  passwordHash  String
  role          UserRole
  storeId       String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  store         Store?   @relation(fields: [storeId], references: [id])
  orders        Order[]
  deliveries    Delivery[]
  createdBy     User?    @relation("CreatedBy", fields: [createdById], references: [id])
  createdById   String?
  createdUsers  User[]   @relation("CreatedBy")
  approvedOrders Order[] @relation("ApprovedOrders")
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  STORE_OWNER
  STORE_MANAGER
  KITCHEN_STAFF
  DRIVER
}

// Store Management
model Store {
  id                String   @id @default(cuid())
  name              String
  contactName       String
  email             String?
  phone             String
  address           String
  city              String
  region            String
  latitude          Float?
  longitude         Float?
  creditLimit       Decimal  @default(0)
  paymentTerms      Int      @default(30) // days
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  users             User[]
  orders            Order[]
  stockLevels       StoreStock[]
  invoices          Invoice[]
  deliveries        Delivery[]
  returns           Return[]
  temperatureLogs   TemperatureLog[]
}

// Product Catalog
model Product {
  id              String   @id @default(cuid())
  name            String
  sku             String   @unique
  description     String?
  price           Decimal
  unit            String   @default("unit")
  category        String?
  shelfLife       Int      // days
  storageTempMin  Float?   // Celsius
  storageTempMax  Float?   // Celsius
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  orderItems      OrderItem[]
  stockLevels     StoreStock[]
  returns         ReturnItem[]
  kitchenItems    KitchenSheetItem[]
}

// Stock Management
model StoreStock {
  id              String   @id @default(cuid())
  storeId         String
  productId       String
  currentLevel    Int
  threshold       Int      @default(10)
  lastUpdated     DateTime @default(now())
  updatedBy       String?  // userId
  
  store           Store    @relation(fields: [storeId], references: [id])
  product         Product  @relation(fields: [productId], references: [id])
  
  @@unique([storeId, productId])
  @@index([storeId])
  @@index([productId])
}

// Order Management
model Order {
  id              String      @id @default(cuid())
  orderNumber     String      @unique
  storeId         String
  createdById     String
  status          OrderStatus @default(DRAFT)
  orderType       OrderType   @default(MANUAL)
  totalAmount     Decimal
  notes           String?
  autoGeneratedAt DateTime?   // when auto-generated
  approvedById    String?
  approvedAt      DateTime?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  store           Store       @relation(fields: [storeId], references: [id])
  createdBy      User        @relation(fields: [createdById], references: [id])
  approvedBy     User?       @relation("ApprovedOrders", fields: [approvedById], references: [id])
  items          OrderItem[]
  kitchenSheet   KitchenSheet?
  delivery       Delivery?
  invoice        Invoice?
}

enum OrderStatus {
  DRAFT           // Auto-generated, pending admin review
  PENDING         // Submitted by store, pending admin approval
  APPROVED        // Approved by admin, ready for kitchen
  KITCHEN_PREP    // Kitchen sheet generated, being prepared
  READY           // Ready for delivery
  IN_DELIVERY     // Out for delivery
  DELIVERED       // Delivered to store
  COMPLETED       // Payment settled, closed
  CANCELLED       // Cancelled
  REJECTED        // Rejected by admin
}

enum OrderType {
  MANUAL          // Manual order by store
  AUTO_REPLENISH  // Auto-generated replenishment order
}

model OrderItem {
  id          String  @id @default(cuid())
  orderId    String
  productId  String
  quantity   Int
  unitPrice  Decimal
  totalPrice Decimal
  
  order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product    Product @relation(fields: [productId], references: [id])
  
  @@index([orderId])
}

// Kitchen Management
model KitchenSheet {
  id              String   @id @default(cuid())
  orderId         String   @unique
  status          KitchenSheetStatus @default(PENDING)
  preparedBy      String?  // userId
  completedAt     DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  order           Order    @relation(fields: [orderId], references: [id])
  items           KitchenSheetItem[]
}

enum KitchenSheetStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

model KitchenSheetItem {
  id              String   @id @default(cuid())
  kitchenSheetId  String
  productId       String
  quantity        Int
  batchNumber     String?
  expiryDate      DateTime?
  barcode         String?
  qrCode          String?
  isPacked        Boolean  @default(false)
  
  kitchenSheet    KitchenSheet @relation(fields: [kitchenSheetId], references: [id], onDelete: Cascade)
  product         Product      @relation(fields: [productId], references: [id])
  
  @@index([kitchenSheetId])
}

// Delivery Management
model Delivery {
  id              String   @id @default(cuid())
  orderId         String   @unique
  driverId        String?
  status          DeliveryStatus @default(PENDING)
  scheduledDate   DateTime
  deliveredAt     DateTime?
  deliveryAddress String
  storeId         String
  latitude        Float?
  longitude       Float?
  signature       String?  // base64 image
  deliveryPhoto   String?  // file URL
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  order           Order    @relation(fields: [orderId], references: [id])
  driver          User?    @relation(fields: [driverId], references: [id])
  store           Store    @relation(fields: [storeId], references: [id])
  temperatureLogs TemperatureLog[]
  returns         Return[]
  payment         Payment?
}

enum DeliveryStatus {
  PENDING
  ASSIGNED
  IN_TRANSIT
  DELIVERED
  FAILED
}

// Temperature & Compliance
model TemperatureLog {
  id              String   @id @default(cuid())
  deliveryId      String?
  storeId         String
  temperature     Float
  location        String?  // "fridge", "freezer", "ambient", etc.
  recordedBy      String?  // userId (driver)
  recordedAt      DateTime @default(now())
  isManual        Boolean  @default(true) // manual vs IoT sensor
  sensorId        String?
  notes           String?
  
  delivery        Delivery? @relation(fields: [deliveryId], references: [id])
  store           Store     @relation(fields: [storeId], references: [id])
  
  @@index([deliveryId])
  @@index([storeId])
  @@index([recordedAt])
}

// Returns & Wastage
model Return {
  id              String   @id @default(cuid())
  deliveryId      String
  storeId         String
  returnedBy      String   // userId (driver)
  returnDate      DateTime @default(now())
  reason          String   @default("expired")
  status          ReturnStatus @default(PENDING)
  processedAt     DateTime?
  notes           String?
  
  delivery        Delivery  @relation(fields: [deliveryId], references: [id])
  store           Store     @relation(fields: [storeId], references: [id])
  items           ReturnItem[]
}

enum ReturnStatus {
  PENDING
  PROCESSED
  REJECTED
}

model ReturnItem {
  id              String   @id @default(cuid())
  returnId        String
  productId       String
  quantity        Int
  expiryDate      DateTime
  reason          String   @default("expired")
  
  return          Return   @relation(fields: [returnId], references: [id], onDelete: Cascade)
  product         Product  @relation(fields: [productId], references: [id])
  
  @@index([returnId])
}

// Invoicing & Payments
model Invoice {
  id              String      @id @default(cuid())
  invoiceNumber   String      @unique
  orderId         String      @unique
  storeId         String
  subtotal        Decimal
  discount        Decimal     @default(0)
  tax             Decimal     @default(0)
  returnAdjustment Decimal    @default(0) // from returns
  totalAmount     Decimal
  dueDate         DateTime
  status          InvoiceStatus @default(PENDING)
  issuedAt        DateTime    @default(now())
  paidAt          DateTime?
  
  order           Order       @relation(fields: [orderId], references: [id])
  store           Store       @relation(fields: [storeId], references: [id])
  payments        Payment[]
  
  @@index([storeId])
  @@index([status])
}

enum InvoiceStatus {
  PENDING
  PARTIAL
  PAID
  OVERDUE
  CANCELLED
}

model Payment {
  id              String      @id @default(cuid())
  invoiceId       String
  deliveryId      String?     @unique
  amount          Decimal
  paymentMethod   PaymentMethod
  paymentDate     DateTime    @default(now())
  transactionId   String?     // from payment gateway
  receiptUrl      String?     // uploaded receipt/photo
  collectedBy     String?     // userId (driver for cash)
  notes           String?
  
  invoice         Invoice     @relation(fields: [invoiceId], references: [id])
  delivery        Delivery?   @relation(fields: [deliveryId], references: [id])
  
  @@index([invoiceId])
}

enum PaymentMethod {
  CASH
  DIRECT_DEBIT
  ONLINE_PAYMENT
  BANK_TRANSFER
}

// Notifications
model Notification {
  id          String   @id @default(cuid())
  userId      String
  title       String
  message     String
  type        NotificationType
  isRead      Boolean  @default(false)
  relatedId   String?  // orderId, invoiceId, etc.
  relatedType String?  // "order", "invoice", etc.
  createdAt   DateTime @default(now())
  
  @@index([userId])
  @@index([isRead])
}

enum NotificationType {
  ORDER_APPROVED
  ORDER_REJECTED
  DELIVERY_ASSIGNED
  PAYMENT_RECEIVED
  INVOICE_GENERATED
  STOCK_LOW
  TEMPERATURE_ALERT
}

